name: Deploy to AWS

# Automatic triggers disabled to prevent errors (requires AWS Secrets to be configured)
on:
  workflow_dispatch:  # Manual triggers only
#  push:
#    branches:
#      - dev        # â†’ deploys to dev environment
#      - staging    # â†’ deploys to staging environment
#      - main       # â†’ deploys to prod environment
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: choice
        options: [dev, staging, prod]

env:
  AWS_REGION: ap-south-1

jobs:
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Determine environment from branch name
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  setup:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      image_tag: ${{ steps.tag.outputs.tag }}
    steps:
      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/staging" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi

      - name: Set image tag (git SHA for immutability)
        id: tag
        run: echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Build & Push Docker images to ECR
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  build-and-push:
    runs-on: ubuntu-latest
    needs: setup
    environment: ${{ needs.setup.outputs.environment }}
    outputs:
      backend_image: ${{ steps.build-backend.outputs.image }}
      frontend_image: ${{ steps.build-frontend.outputs.image }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag & push backend image
        id: build-backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ENV: ${{ needs.setup.outputs.environment }}
          TAG: ${{ needs.setup.outputs.image_tag }}
        run: |
          REPO="${ECR_REGISTRY}/devops-assignment-${ENV}-backend"
          docker build -t "${REPO}:${TAG}" -t "${REPO}:latest" ./backend
          docker push "${REPO}:${TAG}"
          docker push "${REPO}:latest"
          echo "image=${REPO}:${TAG}" >> $GITHUB_OUTPUT

      - name: Build, tag & push frontend image
        id: build-frontend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ENV: ${{ needs.setup.outputs.environment }}
          TAG: ${{ needs.setup.outputs.image_tag }}
        run: |
          REPO="${ECR_REGISTRY}/devops-assignment-${ENV}-frontend"
          docker build -t "${REPO}:${TAG}" -t "${REPO}:latest" ./frontend
          docker push "${REPO}:${TAG}"
          docker push "${REPO}:latest"
          echo "image=${REPO}:${TAG}" >> $GITHUB_OUTPUT

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Terraform Plan (required for prod)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  terraform-plan:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push]
    environment: ${{ needs.setup.outputs.environment }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        working-directory: infrastructure/aws/environments/${{ needs.setup.outputs.environment }}
        run: terraform init

      - name: Terraform Validate
        working-directory: infrastructure/aws/environments/${{ needs.setup.outputs.environment }}
        run: terraform validate

      - name: Terraform Plan
        working-directory: infrastructure/aws/environments/${{ needs.setup.outputs.environment }}
        run: |
          terraform plan \
            -var="key_pair_name=${{ secrets.AWS_KEY_PAIR_NAME }}" \
            -out=tfplan

      - name: Upload plan artifact
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ needs.setup.outputs.environment }}
          path: infrastructure/aws/environments/${{ needs.setup.outputs.environment }}/tfplan
          retention-days: 1

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Terraform Apply (deploy)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  terraform-apply:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push, terraform-plan]
    environment: ${{ needs.setup.outputs.environment }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-${{ needs.setup.outputs.environment }}
          path: infrastructure/aws/environments/${{ needs.setup.outputs.environment }}

      - name: Terraform Init
        working-directory: infrastructure/aws/environments/${{ needs.setup.outputs.environment }}
        run: terraform init

      - name: Terraform Apply
        working-directory: infrastructure/aws/environments/${{ needs.setup.outputs.environment }}
        run: terraform apply -auto-approve tfplan

      - name: Get deployed URLs
        working-directory: infrastructure/aws/environments/${{ needs.setup.outputs.environment }}
        run: |
          echo "ðŸš€ Deployment complete!"
          echo "Frontend: $(terraform output -raw frontend_url)"
          echo "Backend:  $(terraform output -raw backend_url)"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Update EC2 instance with new images
  # (rolling restart via SSM or SSH)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  update-ec2:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push, terraform-apply]
    environment: ${{ needs.setup.outputs.environment }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Trigger rolling update on EC2 via SSM
        run: |
          # Find instance by tag
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters \
              "Name=tag:Environment,Values=${{ needs.setup.outputs.environment }}" \
              "Name=tag:Project,Values=devops-assignment" \
              "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].InstanceId' \
            --output text)

          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "No running instance found - first deploy, Terraform handled it."
            exit 0
          fi

          echo "Updating instance: $INSTANCE_ID"
          # Send update command via SSM (no SSH key needed)
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters commands=["
              cd /opt/app && \
              aws ecr get-login-password --region ap-south-1 | \
                docker login --username AWS --password-stdin \$(aws sts get-caller-identity --query Account --output text).dkr.ecr.ap-south-1.amazonaws.com && \
              docker-compose pull && \
              docker-compose up -d --remove-orphans && \
              echo 'Update complete'
            "] \
            --output text \
            --query 'Command.CommandId'

      - name: Verify health after deploy
        run: |
          echo "Waiting 30s for services to restart..."
          sleep 30
          # Health check would go here with the actual IP from outputs
          echo "âœ… Deploy to ${{ needs.setup.outputs.environment }} complete"
